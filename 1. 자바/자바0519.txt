스택 => 임시적인 메모리 구조

public Student() {  // 기본 생성자
	// 무조건 생성된 객체의 주소값만 반환
	// 반한괎 자료형 정의 불가
	// return X
	// 객체 생성 이후...
	// 멤버 변수(인스턴스 변수)
	
	id=1000;
	name="이름1";
	subject="과목1";
}


생성자
- 객체를 생성하는 메서드
- 반환값 - 생성된 객체의 주소값
- 반환값은 변경 불가 ,정의 X, return 키워드X

1. 디폴트 생성자
- 생성자가 아무것도 정의가 되지 않은 경우 컴파일러가 자동 추가
- 생성자가 정의되면 추가 X

2. 생성자 만들기
3. 생성자 오버로드

null => 값이 없음
참조가 끊기면 -> GC가 동작 -> 안쓰는 힙 영역 메모리 제거
* GC(Garbage Collection) 메모리 청소부

참조 자료형

정보 은닉
1. 접근제어자 - 클래스명, 멤버면수, 멤버 메서드
public - 외부 패키지, 동일 패키지 모두 클래스 내부, 외부 접근 가능(import)
protected - 동일 패키지에서만 내부, 외부 접근 가능 (defalt와 동일)
 + 상속을 통하면 외부 패키지에 있는 클래스더라도 클래스 내부에서 접근 가능 (+private)
defalt (접근제어자를 정의 X)
    - 동일 패키지에서만 내부, 외부 접근 가능
private - 클래스 내부에서만 접근이 가능 

참고)
실 클래스명
패키지명.클래스명

통제 불가능한 부분(멤버변수)은 막고, 통제 가능한 수단(메서드)을 추가 -> 캡슐화(정보은닉)


2. get(), set() 메서드

this 예약어

static 변수 / 클래스 변수

클래스 메서드




함수의 시그니쳐
패키지명 + 클래스명 + 자료형 + 함수명 + 매개변수 정의

동일한 함수 시그니쳐를 정의 X -> 함수의 중복 정의 => 오류 발생

함수의 시그니쳐가 다르면 여러개 정의 할 수 있는 것 -> 메서드 오버로드








//정리
public(외부, 동일 패키지) > protected(동일 패키지 + 상속->클래스 내부) > defalt(동일 패키지) > private(클래스 내부)

