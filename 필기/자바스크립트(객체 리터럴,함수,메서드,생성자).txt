객체
1. 객체 리터럴
- 객체는 이름과 값을 한쌍을 묶은 데이터를 여러개 모은 것
- 객체는 데이터 여러개를 하나로 모은 복합 데이터로 연관배열 또는 사전(Diction) 이라고 부릅니다.

2. 객체 리터럴로 객체 생성하기
	{
		속성 : 값,
		속성 : 값,
		...
	}
	
	값 : 원시타입(숫자, 문자, null, undefined, ..., true, false), 객체
	
	참고)
		자바스크립트는 원시타입을 제외하면 모든것이 객체!
		
		속성 - 프로퍼티(property)
		
	객체의 속성에 접근 하는 법
	
	마침표 연산자(.)
		- 변수명.속성명;
		- 변수로 속성명을 대체 X
		- 숫자도 사용 불가
		
	대괄호 연산자([..])
		- 변수명['속성명']
		- 변수로 속성명을 대체
		- 숫자도 속성명으로 사용 가능
	
	속성값 변경 : 이미 있는 속성에 값을 대입하면 변경
	
3. 프로퍼티 추가와 삭제
	추가
		- 객체에 없는 속성명에 대입하시면 추가

	삭제
		delete 변수명.속성명;

4. in 연산자로 프로퍼티가 있는지 확인하기
	- 객체에 특정 속성이 포함되어 있는지 체크하는 연산자
	"속성명" in 객체의 변수명 / true / false
	
	-> for (... in ) 구문에서 많이 사용 된다.
	
		for ( var key in person) {
			console.log(key, person[key]);
		}

5. 메서드
	- 객체안에 값으로써 함수 객체가 오면, 메서드

6. 객체는 참조 타입
	- 객체에 대입되어 있는 변수 : 참조변수
	- 주소값을 가지고 객체를 참조한다.



함수
- 일련의 처리를 하나로 모아 언제든 호출할 수 있도록 만들어 놓은 것

1. 함수 선언문으로 함수 정의하기
function 함수명(매개변수, ...) {
	// 실행코드
	
	return 반환값; // return이 없으면 - undefined 값이 반환
}


2. 함수 호출
	 함수명(...);
	 
3. 함수의 실행흐름
4. 함수 선언문의 끌어올림 : 호이스팅

5. 값으로서의 함수
	- 함수가 객체
		(매개변수, 반환값)
		
6. 참조에 의한 호출과 값에 의한 호출
	- 함수가 객체


참고)
	함수 객체 - 1급 객체
		1) 값으로 사용 가능 (함수형 프로그래밍)
			 - 매개변수
			 - 반환값
			 - 함수 안에 함수를 정의(중첩 함수 정의)
	
		2) 다른 객체를 생성해주는 객체 - 생성자 함수 객체
		
		
변수의 유효범위
1. 전역 유효 범위와 지역 유효 범위
	평가(번역) -> EC 객체 생성
		- 유효범위 체인
		
2. 변수의 충돌
	- 지역에 있는 변수가 우선

3. 함수 안에서 변수 선언과 변수 끌어올림
	평가(번역) -> EC 객체 생성
								- 변수 레코드

4. 함수 안에서 변수 선언 생략

5. 블록 유효 범위 : let과 const
	
	var : 지역 범위 : 함수 스코프
		- ES6+ : 사용 지양
		
	
	-- 유효범위 {  } --
	let : 변수 선언자
	const : 상수 선언자
		- ES6+ 변수 사용 권장사항
			- 변수는 const 선언자로 일단 선언
			- 변경이 필요한 변수인 경우만 선별적으로 let로 선언

6. 함수 리터럴로 함수 정의하기
const add = function(num1, num2) {
	return num1 + num2;
};

- 함수 리터럴이 정의된 시점 이후부터 실행 가능

7. 객체의 메서드
	
8. 매개변수로 함수
	- 함수가 객체 : 값으로 사용 가능
		- 매개변수, 반환값

9. 즉시 실행 함수
	- 함수를 정의하자 바로 실행
	
	(function() {
		// 실행코드
		
	})();
	
	- 매개변수 사용 가능
	- 반환값 사용 가능

10. 가변길이 인수 목록(Arguments 객체)
	- 모든 함수 객체에 정의된 지역 변수
		arguments
			- 배개변수 값
			- callee : 호출한 함수의 참조값 / 재귀 함수
		
	참고)
		자바스크립트의 매개변수는 매우 유연하다.
			- 정의된 것보다 더 써도 되고, 덜 써도 문제 X
			
		ES6+
				...변수명 : 가변 매개변수 / 전개 연산자
		
11. 생성자
	- 다른 객체를 생성해 주는 함수 객체 (1급 객체...)
	
	- new 연산자를 통해서 생성
			const 변수명 = new 생성자 함수();
			
	- 객체가 생성되는 과정
		- 생성자 함수 객체의 prototype 객체의 상속 과정
		- prototype
							.constructor : 함수 그 자체를 스스로 참조하는 변수
							
----------------------------------------------------------------

function Person() {
    this.name = "이이름";
    this.age = 40;
}
undefined

const p1 = {};
undefined

Object.setPrototypeOf(p1, Person.prototype);
Person {}

Person.prototype.constructor.apply(p1); // constructor : 멤버 변수의 초기화??
undefined

p1;
Person {name: '이이름', age: 40}

----------------------------------------------------------------
	
	
	참고)
		자바스크립트 상속
		
		객체간의 상속 : 프로토타입 체인의 연결 관계
		
		
		[[Prototype]] : 프로토타입 체인
		_proto_ : 브라우저에 따라서 호환이 안되는 경우도 있다.
							Object.setPrototypeOf(...)
							
		
		
		function 예약어로 함수를 정의하면 -> Function.prototype 상속
			Function 함수명 = new Function("매개변수 정의", "실행내용 정의");
			
			
		instanceof 연산자 : 프로토타입의 체인 연결 관계를 체크 / 객체의 출처를 체크
		
		
		function 함수 -> Function.prototype -> Object.prototype
		

----------------------------------------------------------------

생성자간 상속

1. 생성자 함수의 prototype 객체의 상속

class 구문
	- class를 가장한 생성자 함수 객체
	
	ES6 - 클래스 또는 객체 내에서 함수의 축약표현
		this.getArea = function() {
			
		}
		
		getArea() {
		
		}


----------------------------------------------------------------

function Ellipse(a, b) {
    this.a = a;
    this.b = b;
}

Ellipse.prototype.getArea = function() {
    return this.a * this.b * Math.PI;
};

function Circle(r) {
    Ellipse.call(this, r, r);
    this.r = r;
}

Circle.prototype.toString = function() {
    return `Circle : 반지름 ${this.r}, 넓이 ${this.getArea()}`;
};

Object.setPrototypeOf(Circle.prototype, Ellipse.prototype);

----------------------------------------------------------------
// class	

class Ellipsis {
    static count = 0;
    
    constructor(a, b) {
        this.a = a;
        this.b = b;
    }

    getArea() {
        return this.a * this.b * Math.PI;
    }

    static getCount() {
        return Ellipsis.count++;
    }
}

class Circle extends Ellipsis {
    constructor(r) {
        super(r, r);
        this.r = r;
    }
}

----------------------------------------------------------------
	
정보은닉 - 캡슐화

setter와 getter

	set 메서드 : setter
	get 메서드 : getter
	메서드 : 축약표현
	
	
완전한 정보은닉은 아니다.
----------------------------------------------------------------

const person = {
	_name : null,
	_age : null,
	set name(name) {
		this._name = name;
	},
	get name() {
		return this._name;
	},
	set age(age) {
		this._age = age;
	},
	get age() {
		return this._age;
	}
};

----------------------------------------------------------------

완전한 정보 은닉을 위해서는 즉시 실행 함수를 응용해야한다.
----------------------------------------------------------------

const person = (function() {
	let _name, _age;
	
	return {
		set name(name) {
			_name = name;
		},
		get name() {
			return _name;
		},
		set age(age) {
			_age = age;
		},
		get age() {
			return _age;
		}
	}
})();

----------------------------------------------------------------

class Person { constructor(_name, _age) { this.name = _name; this._age = age; }
	set name(name) {
		this._name = name;
	}
	
	get name() {
		return this._name;
	}
	
	set age(age) {
		this._age = age;
	}
	
	get age() {
		return this._age;
	}
}

----------------------------------------------------------------


화살표 함수
- 함수를 매개변수로 사용되는 경우

1. function, 함수명 생략
2. 매개변수 정의 부분 구현 코드 사이 =>
3. 구현 코드가 한줄 일 경우 {...} 생략, return 예약어도 생략 가능
4. 매개변수가 1개일 경우 (...) 생략 가능. 다만, 매개변수가 없는 경우 (...) 생략 불가하다.

----------------------------------------------------------------

const add = (num1, num2) => num1 + num2;

생략

const add = (a, b) => a + b;

매개변수가 1개일 경우 : () 생략
const print = x => console.log(x);

매개변수가 없을 경우 : () 생략 안됨
const print2 = () => console.log("출력");

----------------------------------------------------------------

- this는 함수를 정의할 때 결정 (this의 범위를 변경 X)
- agruments 객체 X